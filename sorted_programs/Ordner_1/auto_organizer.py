import os  # Dateisystem-Zugriff (verwendet Zeile 23, 45, 67)
import shutil  # Datei-Operationen (verwendet Zeile 32, 58)
import ast  # Python-Parser (verwendet Zeile 14, 28)
from pathlib import Path  # moderne Pfade (verwendet Zeile 18, 42)

MAX_MAIN_FOLDERS = 7  # Hauptordner-Limit (Ticket-Anforderung)
MAX_FILES_PER_FOLDER = 9  # Dateien-Limit (Ticket-Anforderung)

def get_all_programs():  # Programme sammeln (verwendet Zeile 52)
    base_path = Path(".")  # aktuelles Verzeichnis (Basis)
    programs = list(base_path.glob("*.py"))  # Python-Dateien (Filter)
    programs.extend(base_path.glob("**/*.py"))  # rekursiv suchen (Vollständigkeit)
    return [p for p in programs if "pycache" not in str(p)]  # Cache ausschließen (Clean)

def verify_syntax(file_path):  # Syntax prüfen (verwendet Zeile 17, 47)
    try:  # Fehlerbehandlung (Robustheit)
        with open(file_path, 'r', encoding='utf-8') as f:  # Datei öffnen (Read-Mode)
            content = f.read()  # Inhalt lesen (String)
        ast.parse(content)  # Python-Syntax (Validation)
        return True, "Syntax OK"  # Erfolg (Boolean + Message)
    except Exception as e:  # Syntax-Fehler (Exception-Handling)
        return False, f"Fehler: {e}"  # Fehlschlag (Error-Info)

def check_requirements(file_path):  # Code-Anforderungen (verwendet Zeile 22)
    try:  # Fehlerbehandlung (Robustheit)
        with open(file_path, 'r', encoding='utf-8') as f:  # Datei öffnen (Read-Mode)
            lines = f.readlines()  # Zeilen lesen (List)
        
        issues = []  # Problem-Liste (Collection)
        in_function = False  # Funktion-Status (State)
        func_lines = 0  # Zeilen-Zähler (Counter)
        
        for line in lines:  # alle Zeilen (Iteration)
            if line.strip().startswith("def "):  # Funktion-Start (Detection)
                if func_lines > 7:  # Zeilen-Limit (Check)
                    issues.append(f"Funktion zu lang: {func_lines} Zeilen")  # Problem (Report)
                in_function, func_lines = True, 1  # Reset (State-Update)
            elif in_function:  # in Funktion (Context)
                func_lines += 1  # Zeilen zählen (Increment)
            
            if not line.strip().endswith("  # "):  # Kommentar-Check (Basic)
                if line.strip() and not line.strip().startswith("#"):  # Code-Zeile (Filter)
                    if "  # " not in line:  # Kommentar fehlt (Validation)
                        issues.append("Zeile ohne Kommentar")  # Problem (Report)
        
        return len(issues) == 0, issues  # Ergebnis (Boolean + Issues)
    except Exception as e:  # Datei-Fehler (Exception)
        return False, [f"Lese-Fehler: {e}"]  # Fehlschlag (Error-Info)

def process_group(group):  # Gruppe verarbeiten (verwendet Zeile 62)
    results = []  # Ergebnis-Liste (Collection)
    for file_path in group:  # alle Dateien (Loop)
        syntax_ok, syntax_msg = verify_syntax(file_path)  # Syntax (Zeile 14)
        req_ok, req_issues = check_requirements(file_path)  # Anforderungen (Zeile 27)
        
        result = {  # Ergebnis-Dict (Data-Structure)
            "file": str(file_path),  # Datei-Pfad (String)
            "syntax": syntax_ok,  # Syntax-Status (Boolean)
            "syntax_msg": syntax_msg,  # Syntax-Nachricht (String)
            "requirements": req_ok,  # Anforderungen-Status (Boolean)
            "req_issues": req_issues  # Problem-Liste (Array)
        }  # Dict-Ende (Structure)
        results.append(result)  # zur Liste (Add)
        
        print(f"✓ {file_path.name}: Syntax={syntax_ok}, Req={req_ok}")  # Status (Debug)
    return results  # Ergebnis-Return (Data)

def create_sorted_structure():  # Ordner-Struktur (verwendet Zeile 77)
    base_dir = Path("sorted_programs")  # Ziel-Verzeichnis (Target)
    base_dir.mkdir(exist_ok=True)  # Verzeichnis erstellen (Create)
    
    for i in range(MAX_MAIN_FOLDERS):  # alle Hauptordner (Loop)
        folder = base_dir / f"Ordner_{i+1}"  # Ordner-Pfad (Path)
        folder.mkdir(exist_ok=True)  # erstellen (Create)
    return base_dir  # Basis-Pfad (Return)

def find_available_folder(base_dir):  # freien Ordner finden (verwendet Zeile 87)
    for i in range(MAX_MAIN_FOLDERS):  # alle Hauptordner (Check)
        folder = base_dir / f"Ordner_{i+1}"  # Ordner-Pfad (Path)
        if len(list(folder.glob("*.py"))) < MAX_FILES_PER_FOLDER:  # Platz-Check (Validation)
            return folder  # freier Ordner (Return)
    
    # Unterordner erstellen (Overflow-Handling)
    counter = 1  # Zähler (Counter)
    while True:  # Endlos-Schleife (Search)
        sub_folder = base_dir / f"Overflow_{counter}"  # Unterordner (Path)
        if not sub_folder.exists() or len(list(sub_folder.glob("*.py"))) < MAX_FILES_PER_FOLDER:  # Check (Condition)
            sub_folder.mkdir(exist_ok=True)  # erstellen (Create)
            return sub_folder  # gefunden (Return)
        counter += 1  # weitersuchen (Increment)

def sort_programs_into_folders(programs, base_dir):  # Programme sortieren (verwendet Zeile 97)
    for program in programs:  # alle Programme (Loop)
        target_folder = find_available_folder(base_dir)  # Ziel-Ordner (Zeile 82)
        target_path = target_folder / program.name  # Ziel-Pfad (Path)
        
        try:  # Fehlerbehandlung (Robustness)
            shutil.copy2(program, target_path)  # kopieren (Copy)
            print(f"📁 {program.name} → {target_folder.name}")  # Status (Info)
        except Exception as e:  # Kopier-Fehler (Exception)
            print(f"❌ Fehler bei {program.name}: {e}")  # Fehler-Info (Error)

def main():  # Hauptfunktion (Entry-Point)
    print("🔍 Sammle alle Programme...")  # Status (Start)
    programs = get_all_programs()  # Programme holen (Zeile 8)
    print(f"📊 {len(programs)} Programme gefunden")  # Anzahl (Info)
    
    print("\n🧪 Überprüfe jeweils 3 Programme...")  # Status (Process)
    for i in range(0, len(programs), 3):  # 3er-Gruppen (Loop)
        group = programs[i:i+3]  # Gruppe bilden (Slice)
        print(f"\n--- Gruppe {i//3 + 1}: {len(group)} Programme ---")  # Gruppe-Info (Header)
        results = process_group(group)  # Gruppe prüfen (Zeile 47)
    
    print("\n📁 Erstelle sortierte Struktur...")  # Status (Sort)
    base_dir = create_sorted_structure()  # Struktur erstellen (Zeile 67)
    sort_programs_into_folders(programs, base_dir)  # sortieren (Zeile 92)
    print(f"✅ Fertig! Alle Programme in {base_dir} sortiert")  # Abschluss (Success)

if __name__ == "__main__":  # Direktstart-Check (Standard)
    main()  # Programm ausführen (Entry)